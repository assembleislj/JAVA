1 重入锁
也叫做递归锁
如果当前线程已经获得了某个监视器对象所持有的锁，那么该线程在该方法中调用另外一个同步方法也同样持有该锁。
例如
public synchronized void methodA() {  
    // 調用相同监视器对象中的其他 synchronized方法  
    this.methodB();  
}  
  
public synchronized void methodB() {  
    // 其他代码  
}
因为进入 methodA时已经获得了该监视器对象持有的锁，当从 methodA跳转到 methodB时就不必再去获取锁了。
可重入锁最大的作用是避免死锁。

2 中断锁
在某些条件下可以相应中断的锁

3 synchronized
提供的锁不是绝对公平的
重入锁
非中断锁

4 ReentrantLock
有公平锁和非公平锁，非公平锁的性能要好于公平锁
重入锁
可成为中断锁,见方法lockInterruptibly()

ReentrantLock的重要方法

lock() 获得锁,如果所被占用，则等待
unlock() 释放锁,需要在catch或finally块中声明
tryLock() 此方法不等待 
当前线程获得此锁，则将保持计数加 1，该方法将返回true
如果锁被另一个线程保持，则此方法将立即返回false值

tryLock(long timeout, TimeUnit unit) 给定时间内尝试获得锁
当前线程获得此锁,则将保持计数加1，该方法将返回true
如果超出了指定的等待时间,则返回值为false

lockInterruptibly() 获得锁，但优先响应中断
如果锁被另一个线程保持，该线程将一直处于休眠状态，在这个状态中其他某个线程可以中断当前线程

5 ReadWriteLock
读写锁，适合读多写少的场景

6 Condition
await() 当前线程进入等待状态，直到被通知(signal())或者被中断.功能类似Object.wait(),等待锁时可被中断
awaitUninterruptibly() 同await()，但不可被中断
signal() 唤醒一个等待在Condition上的线程,功能类似Object.notify()
signalAll() 唤醒等待在Condition上所有的线程,功能类似Object.notifyAll()




